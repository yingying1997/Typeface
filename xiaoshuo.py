import requests  # 导入 requests 库，用于发送 HTTP 请求和处理 HTTP 响应
from lxml import etree  # 导入 lxml 库中的 etree 模块，用于解析 HTML 文档
from fontTools.ttLib import TTFont  # 导入 fontTools 库中的 TTFont 模块，用于处理 TrueType 字体文件

# 目标 url
url = 'https://fanqienovel.com/reader/7081837085425926656?enter_from=reader'
# 请求头信息，模拟浏览器发送请求
head = {
 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36'
}

# 发送 get 请求，获取目标网页的响应对象
res = requests.get(url, headers=head)
# 打印响应内容
# print(res.text)

# 使用 lxml 库中的 etree 模块解析 HTML 响应内容
html = etree.HTML(res.text)
# 使用 XPath 定位到目标元素，并提取其中的文本内容
contents = html.xpath('//div[@class="muye-reader-content noselect"]//text()')
# 打印提取的内容
# print(contents)

# 加载字体文件
fq = TTFont('dc027189e0ba4cd.woff2')
# 借助 xml 格式，查看字体之间的映射关系
fq.saveXML('fq.xml')
# 获取 fq 对象的最佳字符映射表
name = fq.getBestCmap()
# 返回的是字典格式，数据显示不一样。得到的 key 显示的是10进制，需要转换成16进制
# print(name)
# 创建一个空字典用于存储转换后的字符映射表
dic = {}
# 遍历原字符映射表的键值对
for k, v in name.items():
    # 将键转换为十六进制表示形式
    k = hex(k)
    # 去除十六进制表示中的前缀"0x"
    new_key = str(k)[3:]
    # 将转换后的键值对存储到字典中
    dic[new_key] = v

# 打印转换后的字符映射表
# print(dic)

# 通过百度智能云文字识别，将所有文字识别出来后，组合成列表
lst = [
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b',
    'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B',
    'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '的', '一',
    '是', '了', '我', '不', '人', '在', '他', '有', '这', '个', '上', '们', '来',
    '到', '时', '大', '地', '为', '子', '中', '你', '说', '生', '国', '年', '着',
    '就', '那', '和', '要', '她', '出', '也', '得', '里', '后', '自', '以', '会',
    '家', '可', '下', '而', '过', '天', '去', '能', '对', '小', '多', '然', '于',
    '心', '学', '么', '之', '都', '好', '看', '起', '发', '当', '没', '成', '只',
    '如', '事', '把', '还', '用', '第', '样', '道', '想', '作', '种', '开', '美',
    '总', '从', '无', '情', '已', '面', '最', '女', '但', '现', '前', '些', '所',
    '同', '日', '手', '又', '行', '意', '动', '方', '期', '它', '头', '经', '长',
    '儿', '回', '位', '分', '爱', '老', '因', '很', '给', '名', '法', '间', '斯',
    '知', '世', '什', '两', '次', '使', '身', '者', '被', '高', '已', '亲', '其',
    '进', '此', '话', '常', '与', '活', '正', '感', '见', '明', '问', '力', '理',
    '尔', '点', '文', '几', '定', '本', '公', '特', '做', '外', '孩', '相', '西',
    '果', '走', '将', '月', '十', '实', '向', '声', '车', '全', '信', '重', '三',
    '机', '工', '物', '气', '每', '并', '别', '真', '打', '太', '新', '比', '才',
    '便', '夫', '再', '书', '部', '水', '像', '眼', '等', '体', '却', '加', '电',
    '主', '界', '门', '利', '海', '受', '听', '表', '德', '少', '克', '代', '员',
    '许', '陵', '先', '口', '由', '死', '安', '写', '性', '马', '光', '白', '或',
    '住', '难', '望', '教', '命', '花', '结', '乐', '色', '更', '拉', '东', '神',
    '记', '处', '让', '母', '父', '应', '直', '字', '场', '平', '报', '友', '关',
    '放', '至', '张', '认', '接', '告', '入', '笑', '内', '英', '军', '候', '民',
    '岁', '往', '何', '度', '山', '觉', '路', '带', '万', '男', '边', '风', '解',
    '叫', '任', '金', '快', '原', '吃', '妈', '变', '通', '师', '立', '象', '数',
    '四', '失', '满', '战', '远', '格', '士', '音', '轻', '目', '条', '呢'
]
# 获取字体文件中的字形顺序，去除第一个列表里面的空值
order = fq.getGlyphOrder()[1:]
# 打印字形顺序
# print(order)
# 使用字形顺序和给定列表 lst 创建一个新的字典
new_dic = dict(zip(order, lst))
# 打印新的字典
# print(new_dic)

# 在替换之前，将列表里面的数据转成字符串类型的数据
content_str = str(contents)
# 遍历字典 dic 的键值对
for k, v in dic.items():
    # 根据字典 value 的值在新字典 new_dic 中获取对应的字体值
    value = new_dic[v]
    # 打印键和对应的 value
    # print(k, value)
    # 将加密文字替换成对应文字
    content_str = content_str.replace(k, value)

# 去除数据中所有的 \ue
content_str1 = content_str.replace(r'\ue', '')

# 打印最终处理后的字符串
print(content_str1)